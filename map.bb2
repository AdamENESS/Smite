;map.bb2
XINCLUDE "debug.bb2"
XINCLUDE "types.bb2"

XINCLUDE "Items.bb2"
XINCLUDE "bitfont.bb2"
function .l LoadMap{path.s}
    QAMIGA
    dummy.b =0
    If ReadFile(0,path.s)
      DEFTYPE .Level *newLevel
      *newLevel = AllocMem_(sizeof .Level,0)
      ; Lazy skip header
      ReadMem 0, &dummy, 1
      ReadMem 0, &dummy, 1
      ReadMem 0, &dummy, 1
      ReadMem 0, &dummy, 1
      ReadMem 0, &dummy, 1
      ReadMem 0, &dummy, 1
      ReadMem 0, &dummy, 1
      ReadMem 0, &dummy, 1

      for i.w=0 to 4096
      tmp.b =0
        
        ReadMem 0, &tmp.b, 1
        
        if (tmp.b=0)
          *newLevel\walldata[i+0] = 0
        else
        *newLevel\walldata[i+0] = 1
        endif
        
      next
    end if
    vwait 50
    blitz
    function Return *newLevel  
End Function

Statement GenerateMap{seed.w}

End Statement

function .l MakeDemoMap{}
  DEFTYPE .Level *newLevel
    *newLevel = AllocMem_(sizeof .Level,0)
    Restore demomap
    For i.w=0 To 1023
      Read tmp.b
      if tmp.b = 5
        *newLevel\walldata[i*4] = 0
        *newLevel\walldata[(i*4)+1] = 1
      else
        *newLevel\walldata[i*4] = tmp.b
         *newLevel\walldata[(i*4)+1] = 0

      end if
    Next
    function Return *newLevel  

  demomap:
  data .b 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  data .b 1,0,0,3,0,3,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,6,1,0,0,1,0,2,0,3,0,0
  data .b 1,0,0,1,0,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,1,0,0,1,1,1,2,1,1,1
  data .b 1,1,1,1,0,1,1,1,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,5,0,0,0,0,1
  data .b 1,0,0,2,0,2,0,0,1,1,1,1,0,1,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1,1
  data .b 1,0,0,1,0,1,0,0,1,0,0,0,0,1,0,0,0,2,0,0,0,1,0,0,0,0,1,0,0,0,0,1
  data .b 1,1,1,1,0,1,1,1,1,5,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,2,0,1,1,0,1
  data .b 1,0,0,2,0,2,0,0,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1
  data .b 1,0,0,1,0,1,0,0,1,0,0,0,0,5,1,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,1
  data .b 1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,1,0,1
  data .b 1,0,0,4,0,2,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,1
  data .b 1,0,0,1,0,1,0,5,1,0,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,0,0,1
  data .b 1,1,1,1,0,1,1,1,1,1,1,2,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,0,0,1,0,1
  data .b 1,0,0,2,0,2,0,0,1,0,4,0,0,0,2,0,0,2,0,0,0,0,0,2,0,0,2,0,1,1,0,1
  data .b 1,0,0,1,0,1,0,0,1,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,0,0,1,0,1
  data .b 1,1,1,1,0,1,1,1,1,0,0,5,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,1
  data .b 1,0,0,2,0,2,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,1
  data .b 1,0,0,1,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,1,1,1,5,1,0,0,1,0,1,1,0,1
  data .b 1,1,1,1,0,1,1,1,1,0,0,1,0,0,1,5,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,1
  data .b 1,0,0,2,0,2,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1
  data .b 1,5,0,1,0,1,0,0,1,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,1,1
  data .b 1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,5,1,3,1,1,1,1,0,1,0,1
  data .b 1,0,0,2,0,2,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1
  data .b 1,0,0,1,0,1,0,0,1,0,0,0,2,0,0,0,2,0,0,0,0,1,1,1,1,0,1,1,1,1,4,1
  data .b 1,1,1,1,0,1,1,1,1,1,1,1,1,1,2,1,1,1,2,1,1,1,0,0,0,0,0,0,0,1,0,1
  data .b 1,0,0,2,0,2,0,0,1,5,1,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,1,0,1
  data .b 1,5,0,1,0,1,0,0,1,0,5,1,0,1,0,1,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,1
  data .b 1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1
  data .b 1,0,0,2,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,1
  data .b 1,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1
  data .b 1,1,1,1,0,2,0,1,0,0,1,1,0,1,0,1,0,0,1,0,0,1,0,0,5,1,5,0,0,1,5,1
  data .b 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
End Function

Statement preFillItemPos{}
  shared CMazeItem()
  tmp.w =0
  restore mazeItemPos
  for i=0 to 17
    read tmp.w : CMazeItem(i)\xs = tmp.w
    read tmp.w : CMazeItem(i)\ys = tmp.w
  next
  ;    |-3|-2|-1| 0| 1| 2| 3|
  ;--------------------------
  ; -3 |00|01|02|06|05|04|03|
  ;--------------------------
  ; -2 |  |07|08|11|10|09|  |
  ;--------------------------       
  ; -1 +|  |  |12|14|13|  |  |
  ;--------------------------       
  ;  0 |  |  |15|16|17|  |  |
  ;--------------------------
mazeItemPos:
data .w 0,0 
data .w 0,0
data .w 64,88
data .w 0,0
data .w 0,0
data .w 200, 88
data .w 124, 88
data .w 0,0
data .w 40, 115
data .w 0,0
data .w 192, 115
data .w 120, 115
data .w 35, 141
data .w 218, 141
data .w 123, 141
data .w 0,0
data .w 0,0
data .w 0,0
End Statement

Statement preFillFacing{}

  Shared CMazeDr()
  tmp.b=0

  Restore mazeFacingData
  for i=0 to 3
    
    Read tmp.b : CMazeDr(i)\xs= tmp.b ; scale X
    Read tmp.b : CMazeDr(i)\ys= tmp.b ; scale Y
  next

  mazeFacingData:
  data .b 1,  1     ; north
  data .b	 -1, 1    ; east
  data .b -1, -1    ; south
  data .b 1, -1     ; west



End Statement

Statement preFillPosData{}
  Shared CMazePos()

  Restore mazePosDataNoFacing
  tmp.b =0
  for i=0 to 17

    Read tmp.b : CMazePos(i)\xDelta = tmp.b
    Read tmp.b : CMazePos(i)\yDelta = tmp.b
    ;Read tmp.b : CMazePos(i)\facing = tmp.b
  Next


  mazePosData:
  data .b -3, -3, 1     ; 0
  data .b -2, -3, 1     ; 1
  data .b -1, -3, 1     ; 2
  data .b  1, -3, 3     ; 3
  data .b  2, -3, 3     ; 4
  data .b  3, -3, 3     ; 5
  data .b -2, -3, 2     ; 6
  data .b -1, -3, 2     ; 7
  data .b  2, -3, 2     ; 8
  data .b  1, -3, 2     ; 9
  data .b  0, -3, 2     ; 10
  data .b -2, -2, 1     ; 11
  data .b -1, -2, 1     ; 12
  data .b  1, -2, 3     ; 13
  data .b  2, -2, 3     ; 14
  data .b -1, -2, 2     ; 15
  data .b  1, -2, 2     ; 16
  data .b  0, -2, 2     ; 17
  data .b -1, -1, 1     ; 18
  data .b  1, -1, 3     ; 19
  data .b -1, -1, 2     ; 20
  data .b  1, -1, 2     ; 21
  data .b  0, -1, 2     ; 22 
  data .b -1,  0, 1     ; 23 
  data .b  1,  0, 3     ; 24
  data .b  0,  0, 2     ; 25

  ;    |-3|-2|-1| 0| 1| 2| 3|
  ;--------------------------
  ; -3 |00|01|02| |03|04|05|
  ;    |  |06|07|10|09|08|  |
  ;--------------------------
  ; -2 |  |11|12|  |13|14|  |
  ;    |  |  |15|17|16|  |  |
  ;-------------------------- 
  ; -1 |  |  |18|  |19|  |  |
  ;    |  |  |20|22|21|  |  |
  ;-------------------------- 
  ;  0 |  |  |23|25|24|  |  |
  ;--------------------------


  mazePosDataNoFacing:
  data .b -3, -3     ; 0
  data .b -2, -3     ; 1
  data .b -1, -3     ; 2
  data .b  3, -3     ; 3
  data .b  2, -3     ; 4
  data .b  1, -3     ; 5
  data .b  0, -3     ; 6
  data .b -2, -2     ; 7
  data .b -1, -2     ; 8
  data .b  2, -2     ; 9
  data .b  1, -2     ; 10
  data .b  0, -2     ; 11
  data .b -1, -1     ; 12
  data .b  1, -1     ; 13
  data .b  0, -1     ; 14
  data .b -1,  0     ; 15 
  data .b  1,  0     ; 16
  data .b  0,  0     ; 17 

  ;    |-3|-2|-1| 0| 1| 2| 3|
  ;--------------------------
  ; -3 |00|01|02|06|05|04|03|
  ;--------------------------
  ; -2 |  |07|08|11|10|09|  |
  ;--------------------------       
  ; -1 +|  |  |12|14|13|  |  |
  ;--------------------------       
  ;  0 |  |  |15|16|17|  |  |
  ;--------------------------


End Statement

Statement drawMiniMap{}
  Shared gd.GameData, walls()
  Shared CMazeDr.MazeDir(), CMazePos.MazePos()
  shared wallslookup(), currentView()
  Shared *currentLevel.Level, currentBuffer
  Shared bkgindex
  ;    BitPlanesBitMap currentBuffer, currentBuffer+5, %00011111
  ;  use bitmap currentBuffer+5
  Boxf 179,193, 179+64, 193+34,0
  px = gd\playerLocation MOD 32;
  py = gd\playerLocation/32;div(int(pos), 32).quot;

  for x=-3 to 3
    for y=-3 to 3
      loca.w = (((y+py) & $1f) * 32) + ((x+ px) & $1F) 
      wmi.b = 0
      if (y+py >= 0 and y+py < 32)
        if (x+px >= 0 and x+px < 32)
          wmi.b = *currentLevel\walldata[loca.w*4]
          *currentLevel\walldata[(loca.w*4)+1] = 1
  
        EndIf
      endif
      
        sx.w = ((x+3)*4)
        sy.w = ((y+3)*4)
      if (wmi.b = 2)
        Boxf 194+sx,194+sy,198+sx, 198+sy, 32
      end if
      if (wmi.b = 3)
        Boxf 194+sx,194+sy,198+sx, 198+sy, 18
      endif
      
      if (wmi.b = 1)
        Boxf 194+sx,194+sy,198+sx, 198+sy, 31
      end if
      if (wmi.b = 0)
        Boxf 194+sx,194+sy,198+sx, 198+sy, 18
      endif
      
      if x=0: if y=0
        Boxf 194+sx,194+sy,198+sx, 198+sy, 15
      endif : endif
    next ;y
  next ;x  
 ;use bitmap currentBuffer

End Statement


Statement drawMap{}

  Shared gd.GameData, walls()
  Shared CMazeDr.MazeDir(), CMazePos.MazePos()
  shared wallslookup(), currentView()
  Shared *currentLevel.Level
  Shared bkgindex,currentBuffer
  ;BitPlanesBitMap currentBuffer, currentBuffer+5, %00011111
  ;use bitmap currentBuffer+5
  ;Boxf 179,193, 179+64, 193+34,0
  
  px = gd\playerLocation MOD 32;
	py = gd\playerLocation/32;div(int(pos), 32).quot;
  
  for x=-0 to 31
    for y=0 to 31
      loca.w = (((y) & $1f) * 32) + ((x) & $1F) 
      wmi.b = *currentLevel\walldata[loca.w*4] * *currentLevel\walldata[1+(loca.w*4)]
      sx.w = ((x+3)*4)
      sy.w = ((y+3)*4)
      if (wmi.b = 1)
          Boxf 4+sx,4+sy,8+sx, 8+sy, 31
      else
          Boxf 4+sx,4+sy,8+sx, 8+sy, 18
      endif

      
      if x=px: if y=py
        Boxf 4+sx,4+sy,8+sx, 8+sy, 15
      endif : endif
    next ;y
  next ;x  
  ;Use Bitmap currentBuffer

End Statement

Statement drawRadar{}
  
  Shared gd.GameData
  Shared walls()
  Shared CMazeDr.MazeDir(), CMazePos.MazePos()
  shared wallslookup(), currentView()
  Shared *currentLevel.Level
  Shared bkgindex, currentBuffer
  ;BitPlanesBitMap currentBuffer, currentBuffer+5, %00011111
  ;use bitmap currentBuffer+5
  Boxf 92,195,120,220,0
  px = gd\playerLocation MOD 32;
	py = gd\playerLocation /32;div(int(pos), 32).quot;
  realFacing.b = gd\playerFacing
  facingText.s=""
  if realFacing.b =0
  xn.b=0 : yn.b=-1
  xs.b=0 : ys.b=1
  xe.b=-1 : ye.b=0
  xw.b=1 : yw.b=0
  facingText.s="N"
  
  endif
  
  if realFacing.b = 3
  yn.b=0 : xn.b=-1
  ys.b=0 : xs.b=1
  ye.b=1 : xe.b=0
  yw.b=-1 : xw.b=0
  facingText.s="W"
  
  endif
  
  if realFacing.b = 2
  xn.b=0 : yn.b=1
  xs.b=0 : ys.b=-1
  xe.b=1 : ye.b=0
  xw.b=-1 : yw.b=0
  facingText.s="S"
  
  endif
  
  if realFacing.b = 1
  yn.b=0 : xn.b=1
  ys.b=0 : xs.b=-1
  ye.b=-1 : xe.b=0
  yw.b=1 : xw.b=0
  facingText.s="E"
  
  endif
  
  north.w = (((yn + py) & $1f) * 32) + ((xn + px) & $1F) 
  south.w = (((ys + py) & $1f) * 32) + ((xs + px) & $1F) 
  east.w = (((ye + py) & $1f) * 32) + ((xe + px) & $1F) 
  west.w = (((yw + py) & $1f) * 32) + ((xw + px) & $1F) 
  
  if (*currentLevel\walldata[north.w*4])
    blit #UINORTH,92,195
  else
    blit #UINORTH+1,92,195
  endif
  
  if (*currentLevel\walldata[south.w*4])
    blit #UISOUTH,92,195
  else
    blit #UISOUTH+1,92,195
  endif
  
  if (*currentLevel\walldata[east.w*4])
    blit #UIEAST,92,195
  else
    blit #UIEAST+1,92,195
  endif
  
  if (*currentLevel\walldata[west.w*4])
    blit #UIWEST,92,195
  else
    blit #UIWEST+1,92,195
  endif
  
  drawBitmapTextNoClear{106,207,facingText.s}
  ;use bitmap currentBuffer
end Statement


XINCLUDE "Renderer.bb2"
